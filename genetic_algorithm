import numpy as np
import random
import copy
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
import pandas as pd
from typing import List, Tuple, Dict, Optional
import time

class MultiObjectiveGA:
    def __init__(self, road_network,
                 population_size: int = 100,
                 max_generations: int = 200,
                 crossover_rate: float = 0.8,
                 mutation_rate: float = 0.1,
                 terrain_type: str = 'flat',
                 elevation_factor: float = 1.0,
                 road_condition_factor: float = 1.0
                 ):
        self.road_network = road_network
        self.population_size = population_size
        self.max_generations = max_generations
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.terrain_type = terrain_type
        self.elevation_factor = elevation_factor
        self.road_condition_factor = road_condition_factor
        self.dmax = self._calculate_terrain_based_dmax()

        # 提取问题数据
        self._extract_problem_data()

        # 算法状态
        self.population = []
        self.pareto_front = []
        self.generation = 0
        self.history = {
            'best_obj1': [],
            'best_obj2': [],
            'pareto_size': [],
            'generation': []
        }
        print(f"GA initialization complete")
        print(f"Demand point amount: {self.num_demands}")
        print(f"Gathering point amount: {self.num_gathering}")
        print(f"Population size: {self.population_size}")
        print(f"Max tetration times : {self.max_generations}")

    def _extract_problem_data(self):
        """从路网选择器中提取问题数据"""
        # 检查必要数据
        if not hasattr(self.road_network, 'region_centroid_nodes') or not self.road_network.region_centroid_nodes:
            raise ValueError("Demand point not found，finish the network selection first.")

        if not hasattr(self.road_network, 'gathering_points') or not self.road_network.gathering_points:
            raise ValueError("Gathering point not found，finish the network selection first.")

        if not hasattr(self.road_network, 'distance_matrix') or self.road_network.distance_matrix is None:
            raise ValueError("Distance matrix not found，finish the network selection first.")

        if not hasattr(self.road_network, 'demand_quantities') or not self.road_network.demand_quantities:
            raise ValueError("Demands data not found，finish the network selection first.")

        # 提取需求点信息
        self.demand_nodes = [node_id for node_id, _ in self.road_network.region_centroid_nodes]
        self.num_demands = len(self.demand_nodes)

        # 提取集合点信息
        self.gathering_numbers = sorted(self.road_network.gathering_points.keys())
        self.gathering_nodes = [self.road_network.gathering_points[num]
                                for num in self.gathering_numbers]
        self.num_gathering = len(self.gathering_numbers)

        # 提取需求量
        self.demands = np.array([self.road_network.demand_quantities.get(node, 0)
                                 for node in self.demand_nodes])

        # 提取容量
        self.capacities = np.array([self.road_network.gathering_point_capacities.get(num, 0)
                                    for num in self.gathering_numbers])

        # 提取距离矩阵（使用基于地形的距离限制）
        distance_df = self.road_network.distance_matrix
        self.distance_matrix = np.full((self.num_demands, self.num_gathering), np.inf)
        for i, demand_node in enumerate(self.demand_nodes):
            for j, gathering_node in enumerate(self.gathering_nodes):
                if demand_node in distance_df.index and gathering_node in distance_df.columns:
                    distance = distance_df.loc[demand_node, gathering_node]
                    if not np.isinf(distance) and distance <= self.dmax:
                        self.distance_matrix[i, j] = distance

        print(f"Distance matrix construction complete, using distance limit: {self.dmax:.1f}m")

        # 提取穿越次数矩阵
        self.crossing_matrix = self._get_crossing_matrix()
        print(f"Data read:")
        print(f"  Demand point: {self.demand_nodes}")
        print(f"  Gathering point: {self.gathering_nodes}")
        print(f"  Demands: {self.demands}")
        print(f"  Capacity: {self.capacities}")
        print(f"  Total Demands: {np.sum(self.demands)}")
        print(f"  Total Capacity: {np.sum(self.capacities)}")


    def _calculate_terrain_based_dmax(self) -> float:
        """
        根据地形类型、海拔和路况计算距离限制

        Returns:
            float: 计算后的距离限制
        """
        # 地形类型基础距离（米）
        terrain_base_distances = {
            'flat': 1500,  # 平原：1500米
            'hilly': 1200,  # 丘陵：1200米
        '   mountainous': 900  # 山区：900米
        }

        # 获取地形基础距离
        base_distance = terrain_base_distances.get(self.terrain_type, 1500)

        # 应用海拔和路况调整
        adjusted_distance = base_distance * self.elevation_factor * self.road_condition_factor

        # 限制在合理范围内（500-2000米）
        adjusted_distance = max(500, min(adjusted_distance, 2000))

        print(f"\nTerrain-based distance limit calculation:")
        print(f"  Terrain type: {self.terrain_type}")
        print(f"  Base distance: {base_distance:.1f}m")
        print(f"  Elevation factor: {self.elevation_factor}")
        print(f"  Road condition factor: {self.road_condition_factor}")
        print(f"  Final distance limit: {adjusted_distance:.1f}m")

        return adjusted_distance


    def _get_crossing_matrix(self):
        """获取穿越次数矩阵"""
        if hasattr(self.road_network, 'crossing_matrix') and self.road_network.crossing_matrix is not None:
            return self.road_network.crossing_matrix
        else:
            # 如果没有穿越矩阵，返回零矩阵
            print("No matrix found!")
            return np.zeros((self.num_demands, self.num_gathering))

    def _is_feasible_assignment(self, assignment: np.ndarray) -> bool:
        """
        检查分配方案是否可行

        Args:
            assignment: 分配方案，assignment[i] = j 表示需求点i分配给集合点j，-1表示未分配

        Returns:
            bool: 是否可行
        """
        # 检查容量约束
        for j in range(self.num_gathering):
            total_demand = np.sum(self.demands[assignment == j])
            if total_demand > self.capacities[j]:
                return False

        # 检查距离约束
        for i in range(self.num_demands):
            j = assignment[i]
            if j != -1 and self.distance_matrix[i, j] > self.dmax:
                return False

        return True

    def _generate_random_individual(self) -> np.ndarray:
        """
        生成一个随机的可行个体（纯随机方法，标准NSGA-II）

        Returns:
            np.ndarray: 分配方案
        """
        while True:  # 持续尝试直到生成可行解
            assignment = np.full(self.num_demands, -1)

            # 随机排列需求点顺序
            demand_order = np.random.permutation(self.num_demands)

            success = True
            for i in demand_order:
                # 找到可行的集合点
                feasible_gatherings = []
                for j in range(self.num_gathering):
                    # 检查距离约束
                    if self.distance_matrix[i, j] <= self.dmax:
                        # 检查容量约束
                        current_load = np.sum(self.demands[assignment == j])
                        if current_load + self.demands[i] <= self.capacities[j]:
                            feasible_gatherings.append(j)

                if feasible_gatherings:
                    # 随机选择一个可行集合点
                    j = random.choice(feasible_gatherings)
                    assignment[i] = j
                else:
                    # 无可行分配，重新开始
                    success = False
                    break

            # 如果所有需求点都成功分配，返回
            if success and np.all(assignment != -1):
                return assignment

    def _calculate_objectives(self, assignment: np.ndarray) -> Tuple[float, float]:
        """
        计算目标函数值

        Args:
            assignment: 分配方案

        Returns:
            Tuple[float, float]: (总步行距离, 总穿越次数)
        """
        total_distance = 0.0
        total_crossings = 0.0
        for i in range(self.num_demands):
            j = assignment[i]
            if j != -1:
                total_distance += self.demands[i] * self.distance_matrix[i, j]
                total_crossings += self.demands[i] * self.crossing_matrix[i, j]

        return total_distance, total_crossings

    def _dominates(self, obj1: Tuple[float, float], obj2: Tuple[float, float]) -> bool:
        """
        判断目标1是否支配目标2

        Args:
            obj1: 目标函数值1
            obj2: 目标函数值2

        Returns:
            bool: obj1是否支配obj2
        """
        return (obj1[0] <= obj2[0] and obj1[1] <= obj2[1] and
                (obj1[0] < obj2[0] or obj1[1] < obj2[1]))

    def _initialize_population(self):
        """初始化种群"""
        print("正在初始化种群...")
        self.population = []

        for i in range(self.population_size):
            if i % 20 == 0:
                print(f"  生成个体 {i + 1}/{self.population_size}")
            assignment = self._generate_random_individual()
            objectives = self._calculate_objectives(assignment)

            self.population.append({
                'assignment': assignment,
                'objectives': objectives,
                'rank': 0,
                'crowding_distance': 0.0
            })

        print(f"种群初始化完成，共 {len(self.population)} 个个体")

    def _fast_non_dominated_sort(self):
        """快速非支配排序"""
        fronts = [[]]

        for i, individual_i in enumerate(self.population):
            individual_i['domination_count'] = 0
            individual_i['dominated_solutions'] = []
            for j, individual_j in enumerate(self.population):
                if i != j:
                    if self._dominates(individual_i['objectives'], individual_j['objectives']):
                        individual_i['dominated_solutions'].append(j)
                    elif self._dominates(individual_j['objectives'], individual_i['objectives']):
                        individual_i['domination_count'] += 1

            if individual_i['domination_count'] == 0:
                individual_i['rank'] = 0
                fronts[0].append(i)

        i = 0
        while len(fronts[i]) > 0:
            next_front = []
            for p in fronts[i]:
                for q in self.population[p]['dominated_solutions']:
                    self.population[q]['domination_count'] -= 1
                    if self.population[q]['domination_count'] == 0:
                        self.population[q]['rank'] = i + 1
                        next_front.append(q)
            i += 1
            fronts.append(next_front)

        return fronts[:-1]

    def _calculate_crowding_distance(self, front: List[int]):
        """计算拥挤度距离"""
        if len(front) <= 2:
            for i in front:
                self.population[i]['crowding_distance'] = np.inf
            return

        # 初始化距离
        for i in front:
            self.population[i]['crowding_distance'] = 0.0

        # 对每个目标函数
        for obj_idx in range(2):
            # 按目标函数值排序
            front.sort(key=lambda x: self.population[x]['objectives'][obj_idx])

            # 边界点设为无穷大
            self.population[front[0]]['crowding_distance'] = np.inf
            self.population[front[-1]]['crowding_distance'] = np.inf

            # 计算目标函数范围
            obj_min = self.population[front[0]]['objectives'][obj_idx]
            obj_max = self.population[front[-1]]['objectives'][obj_idx]
            obj_range = obj_max - obj_min

            if obj_range > 0:
                for i in range(1, len(front) - 1):
                    distance = (self.population[front[i + 1]]['objectives'][obj_idx] -
                                self.population[front[i - 1]]['objectives'][obj_idx]) / obj_range
                    self.population[front[i]]['crowding_distance'] += distance

    def _tournament_selection(self) -> int:
        """锦标赛选择"""
        tournament_size = 2  # 二元锦标赛
        tournament = random.sample(range(len(self.population)), tournament_size)
        best = tournament[0]
        for i in tournament[1:]:
            # 比较等级
            if self.population[i]['rank'] < self.population[best]['rank']:
                best = i
            elif (self.population[i]['rank'] == self.population[best]['rank'] and
                  self.population[i]['crowding_distance'] > self.population[best]['crowding_distance']):
                best = i

        return best

    def _crossover(self, parent1: np.ndarray, parent2: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """二点交叉操作"""
        if random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()

        # 二点交叉
        point1 = random.randint(1, self.num_demands - 2)
        point2 = random.randint(point1 + 1, self.num_demands - 1)

        child1 = parent1.copy()
        child2 = parent2.copy()

        # 中間部分を交換
        child1[point1:point2] = parent2[point1:point2]
        child2[point1:point2] = parent1[point1:point2]

        # 修復不可行解
        child1 = self._repair_individual(child1)
        child2 = self._repair_individual(child2)

        return child1, child2

    def _mutate(self, individual: np.ndarray) -> np.ndarray:
        """变异操作"""
        if random.random() > self.mutation_rate:
            return individual.copy()

        mutated = individual.copy()

        # 随机选择一个需求点进行变异
        i = random.randint(0, self.num_demands - 1)

        # 找到可行的集合点
        feasible_gatherings = []
        for j in range(self.num_gathering):
            if j != mutated[i] and self.distance_matrix[i, j] <= self.dmax:
                # 检查容量约束
                current_load = np.sum(self.demands[mutated == j])
                if current_load + self.demands[i] <= self.capacities[j]:
                    feasible_gatherings.append(j)

        if feasible_gatherings:
            old_j = mutated[i]
            new_j = random.choice(feasible_gatherings)
            mutated[i] = new_j

        return mutated

    def _repair_individual(self, individual: np.ndarray) -> np.ndarray:
        """修复不可行个体"""
        repaired = individual.copy()

        # 检查并修复容量约束违反
        for j in range(self.num_gathering):
            assigned_demands = np.where(repaired == j)[0]
            total_demand = np.sum(self.demands[assigned_demands])

            if total_demand > self.capacities[j]:
                # 按需求量从大到小排序，移除多余的需求点
                demand_order = assigned_demands[np.argsort(-self.demands[assigned_demands])]
                current_load = 0

                for i in demand_order:
                    if current_load + self.demands[i] <= self.capacities[j]:
                        current_load += self.demands[i]
                    else:
                        # 重新分配这个需求点
                        repaired[i] = self._find_feasible_gathering(i, repaired)

        return repaired

    def _find_feasible_gathering(self, demand_idx: int, current_assignment: np.ndarray) -> int:
        """为需求点找到可行的集合点"""
        for j in range(self.num_gathering):
            if (self.distance_matrix[demand_idx, j] <= self.dmax and
                    np.sum(self.demands[current_assignment == j]) + self.demands[demand_idx] <= self.capacities[j]):
                return j
        return -1  # 无可行分配

    def _environmental_selection(self, fronts: List[List[int]]):
        """环境选择"""
        new_population = []

        for front in fronts:
            if len(new_population) + len(front) <= self.population_size:
                # 整个前沿都可以加入
                new_population.extend(front)
            else:
                # 只能加入部分个体
                remaining_slots = self.population_size - len(new_population)
                self._calculate_crowding_distance(front)

                # 按拥挤度距离降序排序
                front.sort(key=lambda x: self.population[x]['crowding_distance'], reverse=True)
                new_population.extend(front[:remaining_slots])
                break

        # 更新种群
        self.population = [self.population[i] for i in new_population]

    def _update_pareto_front(self):
        """更新帕累托前沿"""
        # 找到第一层前沿
        first_front = []
        for i, individual in enumerate(self.population):
            if individual['rank'] == 0:
                first_front.append(individual)

        self.pareto_front = first_front

    def _record_history(self):
        """记录历史信息"""
        if self.pareto_front:
            objectives = [ind['objectives'] for ind in self.pareto_front]
            obj1_values = [obj[0] for obj in objectives]
            obj2_values = [obj[1] for obj in objectives]

            self.history['best_obj1'].append(min(obj1_values))
            self.history['best_obj2'].append(min(obj2_values))
            self.history['pareto_size'].append(len(self.pareto_front))
        else:
            self.history['best_obj1'].append(float('inf'))
            self.history['best_obj2'].append(float('inf'))
            self.history['pareto_size'].append(0)

        self.history['generation'].append(self.generation)

    def run(self) -> List[Dict]:
        """
        运行遗传算法

        Returns:
            List[Dict]: 帕累托最优解集
        """
        print("\n" + "=" * 60)
        print("开始运行双目标遗传算法")
        print("=" * 60)

        start_time = time.time()

        # 初始化种群
        self._initialize_population()

        for generation in range(self.max_generations):
            self.generation = generation

            # 非支配排序
            fronts = self._fast_non_dominated_sort()

            # 计算拥挤度距离
            for front in fronts:
                self._calculate_crowding_distance(front)

            # 更新帕累托前沿
            self._update_pareto_front()

            # 记录历史
            self._record_history()

            # 输出进度
            if generation % 20 == 0 or generation == self.max_generations - 1:
                print(f"第 {generation + 1} 代: 帕累托前沿大小 = {len(self.pareto_front)}")
                if self.pareto_front:
                    best_dist = min([ind['objectives'][0] for ind in self.pareto_front])
                    best_cross = min([ind['objectives'][1] for ind in self.pareto_front])
                    print(f"  最佳距离: {best_dist:.2f}, 最佳穿越: {best_cross:.2f}")

            # 如果不是最后一代，进行繁殖
            if generation < self.max_generations - 1:
                # 创建子代
                offspring = []
                while len(offspring) < self.population_size:
                    # 选择父母
                    parent1_idx = self._tournament_selection()
                    parent2_idx = self._tournament_selection()

                    parent1 = self.population[parent1_idx]['assignment']
                    parent2 = self.population[parent2_idx]['assignment']

                    # 交叉
                    child1, child2 = self._crossover(parent1, parent2)

                    # 变异
                    child1 = self._mutate(child1)
                    child2 = self._mutate(child2)

                    # 计算目标函数
                    obj1 = self._calculate_objectives(child1)
                    obj2 = self._calculate_objectives(child2)

                    offspring.extend([
                        {'assignment': child1, 'objectives': obj1, 'rank': 0, 'crowding_distance': 0.0},
                        {'assignment': child2, 'objectives': obj2, 'rank': 0, 'crowding_distance': 0.0}
                    ])

                # 合并父代和子代
                self.population.extend(offspring[:self.population_size])

                # 非支配排序
                fronts = self._fast_non_dominated_sort()

                # 环境选择
                self._environmental_selection(fronts)

        end_time = time.time()
        runtime = end_time - start_time
        print(f"\nDistance limit: {self.dmax:.1f}m (Terrain type: {self.terrain_type})")
        print(f"\n算法运行完成，耗时 {runtime:.2f} 秒")
        print(f"最终帕累托前沿包含 {len(self.pareto_front)} 个解")
        print(f"\n" + "帕累托最优解详情（共 {len(self.pareto_front)} 个解）")
        for idx, solution in enumerate(self.pareto_front):
            assignment = solution['assignment']
            obj1, obj2 = solution['objectives']
            # 找出使用的集合点
            used_gps_indices = sorted(set(assignment[assignment != -1]))
            used_gps_numbers = [self.gathering_numbers[j] for j in used_gps_indices]
            print(f"\n【解 {idx + 1}】")
            print(f"  总距离: {obj1:.0f} 人·米")
            print(f"  总穿越: {obj2:.0f} 次")
            print(f"  使用集合点数量: {len(used_gps_indices)}/{self.num_gathering}")
            print(f"  使用的集合点: {used_gps_numbers}")
            print(f"  各集合点负载:")
            for j in sorted(used_gps_indices):
                gp_num = self.gathering_numbers[j]
                assigned_to_j = np.where(assignment == j)[0]
                total_load = np.sum(self.demands[assigned_to_j])
                capacity = self.capacities[j]
                utilization = total_load / capacity * 100
                print(f"    集合点{gp_num}: {total_load:.0f}/{capacity:.0f}人 ({utilization:.1f}%)")
        print(f"\n" + "=" * 60)
        return self.pareto_front

    def visualize_results(self):
        """可视化结果"""
        if not self.pareto_front:
            print("没有找到可行解")
            return

        # 创建图形
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))

        # 1. 帕累托前沿
        objectives = [ind['objectives'] for ind in self.pareto_front]
        obj1_values = [obj[0] for obj in objectives]
        obj2_values = [obj[1] for obj in objectives]

        ax1.scatter(obj1_values, obj2_values, c='red', s=50, alpha=0.7)
        ax1.set_xlabel('Total distance (p·m)')
        ax1.set_ylabel('Total crossing times (p·times)')
        ax1.set_title('Pareto front')
        ax1.grid(True, alpha=0.3)

        # 2. 收敛历史
        ax2.plot(self.history['generation'], self.history['best_obj1'], 'b-', label='Best distance')
        ax2_twin = ax2.twinx()
        ax2_twin.plot(self.history['generation'], self.history['best_obj2'], 'r-', label='Best crossing')
        ax2.set_xlabel('Iteration count')  # 迭代次数
        ax2.set_ylabel('Best distance', color='b')
        ax2_twin.set_ylabel('Best crossing', color='r')
        ax2.set_title('Convergence history')  # 收敛历史
        ax2.grid(True, alpha=0.3)

        # 3. 帕累托前沿大小变化
        ax3.plot(self.history['generation'], self.history['pareto_size'], 'g-')
        ax3.set_xlabel('Iteration count')
        ax3.set_ylabel('Pareto front size')
        ax3.set_title('Pareto front size changes')
        ax3.grid(True, alpha=0.3)

        # 4. 分配方案示例（选择一个代表性解）
        if len(self.pareto_front) > 0:
            # 选择最平衡的解（归一化后距离原点最近）
            normalized_obj1 = np.array(obj1_values) / max(obj1_values)
            normalized_obj2 = np.array(obj2_values) / max(obj2_values)
            distances = np.sqrt(normalized_obj1 ** 2 + normalized_obj2 ** 2)
            best_idx = np.argmin(distances)
            best_solution = self.pareto_front[best_idx]
            assignment = best_solution['assignment']

            # 创建分配表
            allocation_data = []
            for i in range(self.num_demands):
                j = assignment[i]
                if j != -1:
                    gp_num = self.gathering_numbers[j]
                    allocation_data.append([
                        f"Demand point{i + 1}",
                        f"Gathering point{gp_num}",
                        self.demands[i],
                        f"{self.distance_matrix[i, j]:.1f}",
                        f"{self.crossing_matrix[i, j]:.0f}"
                    ])

            df = pd.DataFrame(allocation_data,
                              columns=['Demand point', 'Gathering point', 'Demands(person)', 'Distance(m)', 'Crossing times'])

            # 显示表格
            ax4.axis('tight')
            ax4.axis('off')
            table = ax4.table(cellText=df.values,
                              colLabels=df.columns,
                              cellLoc='center',
                              loc='center')
            table.auto_set_font_size(False)
            table.set_fontsize(9)
            table.scale(1.2, 1.5)
            ax4.set_title(
                f'Best arrangement:\nDistance: {best_solution["objectives"][0]:.1f}, Crossing: {best_solution["objectives"][1]:.1f}')

        plt.tight_layout()
        plt.show()

    def export_results(self, filename: str = "pareto_solutions.csv"):
        """导出帕累托最优解到CSV文件"""
        if not self.pareto_front:
            print("没有找到可行解")
            return

        results = []
        for idx, solution in enumerate(self.pareto_front):
            assignment = solution['assignment']
            obj1, obj2 = solution['objectives']

            # 计算分配统计
            allocated_demands = np.sum(assignment != -1)
            total_allocated_demand = np.sum(self.demands[assignment != -1])

            # 计算集合点利用率
            utilization = []
            for j in range(self.num_gathering):
                used_capacity = np.sum(self.demands[assignment == j])
                util_rate = used_capacity / self.capacities[j] if self.capacities[j] > 0 else 0
                utilization.append(util_rate)

            avg_utilization = np.mean(utilization)
            results.append({
                'solution_id': idx + 1,
                'total_distance': obj1,
                'total_crossings': obj2,
                'allocated_demands': allocated_demands,
                'total_allocated_demand': total_allocated_demand,
                'avg_utilization': avg_utilization,
                'assignment': assignment.tolist()
            })

        df = pd.DataFrame(results)
        df.to_csv(filename, index=False)
        print(f"帕累托最优解已导出到 {filename}")

def run_optimization(road_network_selector,
                    terrain_type='flat',    #在这里调整地形类别：flat/hilly/mountainous
                    elevation_factor=1.0,   # 在这里微调地形参数
                    road_condition_factor=1.0):    # 在这里微调道路参数
    """
    运行优化算法的主函数
    Args:
        road_network_selector: RoadNetworkSelector实例
        terrain_type: 地形类型 ('flat'=平原, 'hilly'=丘陵, 'mountainous'=山区)
        elevation_factor: 海拔影响因子 (0.5-2.0, 值越小距离限制越严格)
        road_condition_factor: 路况影响因子 (0.5-2.0, 值越小距离限制越严格)
    """
    try:
        # 创建遗传算法实例
        ga = MultiObjectiveGA(
            road_network=road_network_selector,
            population_size=100,
            max_generations=200,
            crossover_rate=0.8,
            mutation_rate=0.1,
            terrain_type=terrain_type,
            elevation_factor=elevation_factor,
            road_condition_factor=road_condition_factor
        )

        # 运行算法
        pareto_solutions = ga.run()

        # 可视化结果
        ga.visualize_results()

        # 导出结果
        ga.export_results()

        return ga, pareto_solutions

    except Exception as e:
        print(f"优化过程中出现错误: {e}")
        return None, None

if __name__ == "__main__":
    print("双目标遗传算法模块")
    print("请从主程序调用 run_optimization() 函数")
